            EXTERNAL FUNCTION (KEY,MYTRAN) 
            NORMAL MODE IS INTEGER 
            ENTRY TO CHANGE. 
            LIST.(INPUT) 
            Vector Values G(1)="TYPE","SUBST","APPEND","ADD","START","RANK","DISPLA" 
            Vector Values SNUMB = " I3 *" 
            FIT=0 
CHANGE      PRINT COMMENT "PLEASE INSTRUCT ME" 
            LISTRD.(MTLIST.(INPUT),0) 
            JOB=POPTOP.(INPUT) 
            Through IDENT, FOR J=1,1, J> 7 
IDENT       Whenever G(J) = JOB, Transfer To THEMA 
            PRINT COMMENT "CHANGE NOT RECOGNIZED" 
            Transfer To CHANGE 
THEMA       Whenever J = 5, Function Return IRALST.(INPUT) 
            Whenever J = 7 
                Through DISPLA, FOR I=0,1, I  > 32 
                Whenever LISTMT.(KEY(I)) = 0, Transfer To DISPLA 
                S=SEQRDR.(KEY(I)) 
READ(7)         NEXT=SEQLR.(S,F) 
                Whenever F > 0, Transfer To DISPLA 
                PRINT COMMENT "*" 
                TPRINT.(NEXT,0) 
                PRINT FORMAT SNUMB,I 
                PRINT COMENT " " 
                Transfer To READ(7) 
DISPLA          CONTINUE 
                PRINT COMMENT " " 
                PRINT COMMENT "MEMORY LIST FOLLOWS" 
                PRINT COMMENT " " 
                Through MEMLIST, FOR I=1 , 1, I > 4 
MEMLST          TXTPRT.(MYTRAN(I),0) 
                Transfer To CHANGE 
            End Conditional 
            THEME=POPTOP.(INPUT) 
            SUBJECT=KEY(HASH.(THEME,5)) 
            S=SEQRDR.(SUBJECT) 
LOOK        TERM=SEQLR.(S,F) 
            Whenever F > 0, Transfer To FAIL 
            Whenever TOP.(TERM) = THEME, Transfer To FOUND 
            Transfer To LOOK 
FOUND       Transfer To DELTA(J) 
DELTA(1)    TPRINT.(TERM,0) 
            Transfer To CHANGE 
FAIL        PRINT COMMENT "LIST NOT FOUND" 
            Transfer To CHANGE 
DELTA(2)    S=SEQRDR.(TERM) 
            OLD=POPTOP.(INPUT) 
READ(1)     OBJCT=SEQLR.(S,F) 
            Whenever F > 0, Transfer To FAIL 
            Whenever F <> 0, Transfer To READ(1) 
            INSIDE=SEQRDR.(OBJECT) 
READ(2)     IT=SEQLR.(INSIDE,F) 
            Whenever F > 0, Transfer To READ(1) 
            SIT=SEQRDR.(IT) 
            SOLD=SEQRDR.(OLD) 
ITOLD       TOLD=SEQLR.(SOLD,FOLD) 
            DIT=SEQLR.(SIT,FIT) 
            Whenever TOLD = DIT AND FOLD <= 0,Transfer To ITOLD 
            Whenever FOLD > 0, Transfer To OK(J) 
            Transfer To READ(2) 
OK(2)       SUBST.(POPTOP.(INPUT),LSPNTR.(INSIDE)) 
            Transfer To CHANGE 
OK(3)       NEWBOT.(POPTOP.(INPUT),OBJCT) 
            Transfer To CHANGE 
DELTA(3)    Transfer To DELTA(2) 
DELTA(4)    Whenever NAMTST.(BOT.(TERM)) = 0 
                BOTTOM=POPBOT.(TERM) 
                NEWBOT.(POPTOP.(INPUT),TERM) 
                NEWBOT.(BOTTOM,TERM) 
            Otherwise 
                NEWBOT.(POPTOP.(INPUT),TERM) 
            End Conditional 
            Transfer To CHANGE 
DELTA(6)    S=SEQRDR.(TERM) 
READ(6)     OBJCT=SEQLR.(S,F) 
            Whenever F > 0, Transfer To FAIL 
            Whenever F <> 0, Transfer To READ(6) 
            OBJCT=SEQLL.(S,F) 
            Whenever LNKLL.(OBJECT) = 0 
                SUBST.(POPTOP.(INPUT),LSPNTR.(S)) 
            Otherwise 
                NEWTOP.(POPTOP.(INPUT),LSPNTR.(S)) 
            End Conditional 
            Transfer To CHANGE 
            End Function 

           R* * * * * * * * * * END OF MODIFICATION ROUTINE 

        TPRIN 
            EXTERNAL FUNCTION (LST) 
            NORMAL MODE IS INTEGER 
            ENTRY TO TPRINT. 
            SA=SEQRDR.(LST) 
            LIST.(OUT) 
READ        NEXT=SEQLR.(SA,FA) 
            Whenever FA > 0, Transfer To P 
            Whenever FA = 0, Transfer To B 
            POINT=NEWBOT.(NEXT,OUT) 
            Whenever SA < 0, MRKNEG.(POINT) 
            Transfer To READ 
B           TXTPRT.(OUT,0) 
            SEQLL.(SA,FA) 
MORE        NEXT=SEQLR.(SA,FA) 
            Whenever TOP.(NEXT) = "=" 
                TXTPRT.(NEXT,0) 
                Transfer To MORE 
            End Conditional 
            Whenever FA > 0, Transfer To DONE 
            PRINT COMMENT " " 
            SB=SEQRDR.(NEXT) 
MEHR        TERM=SEQLR.(SB,FB) 
            Whenever FB <0 
                PRINT ON LINE FORMAT NUMBER, TERM 
                Vector Values NUMBER = "I3 *" 
                Transfer To MEHR 
            End Conditional 
            Whenever FB > 0, Transfer To MORE 
            TXTPRT.(TERM,0) 
            Transfer To MEHR 
P           TXTPRT.(OUT,0) 
DONE        IRALST.(OUT) 
            Function Return 
            End Function 

        LPRIN 
            EXTERNAL FUNCTION (LST,TAPE) 
            NORMAL MODE IS INTEGER 
            ENTRY TO LPRINT. 
            BLANK = "      " 
            EXECUTE PLACE.(TAPE,0) 
            LEFTP = 606074606060K 
            RIGHTP= 606034606060K 
            BOTH  = 607460603460K 
            EXECUTE NEWTOP.(SEQRDR.(LST),LIST.(STACK)) 
            S=POPTOP.(STACK) 
BEGIN       EXECUTE PLACE.(LEFTP,1) 
NEXT        WORD=SEQLR.(S,FLAG) 
            Whenever FLAG < 0 
            EXECUTE PLACE.(WORD,1) 
            Whenever S > 0, PLACE.(BLANK,1) 
            Transfer To NEXT 
            OR Whenever FLAG > 0 
            EXECUTE PLACE.(RIGHTP,1) 
            Whenever LISTMT.(STACK) = 0, Transfer To DONE 
            S=POPTOP.(STACK) 
            Transfer To NEXT 
            OTHERWISE 
            Whenever LISTMT.(WORD) = 0 
            EXECUTE PLACE.(BOTH,1) 
            Transfer To NEXT 
            OTHERWISE 
            EXECUTE NEWTOP.(S,STACK) 
            S=SEQRDR.(WORD) 
            Transfer To BEGIN 
            End Conditional 
            End Conditional 
DONE        EXECUTE PLACE.(0,-1) 
            EXECUTE IRALST.(STACK) 
            FUNCTION RETURN LST 
            END OF FUNCTION 

;
; TESTS(CAND, S) return a sequence reader if the keyword matches the user's
;                input text, otherwise return 0.
;
; CAND  is the keyword candidate transformation rule
; S     is the sequence reader for the user INPUT text
;
; This function has 3 tasks
;
;  1. Test whether the whole candidate keyword matches the whole word
;     in the user's input text.
;  2. If the words do match, make any keyword substitution specified
;     in the candidate transformation rule.
;  3. Position the candidate reader past the substitution keyword, if any.
;
; SLIP packs 6 6-bit characters into each 36-bit IBM 7094 machine word.
; If a word has more than 6 characters it is continued into the next SLIP
; cell, with the first cell having its sign bit set. ???
;
; This code abstracts this full-word matching and has the side-effect
; of modifying the user's input text with the substitution word, if
; specified.
;

        TESTS 
            EXTERNAL FUNCTION(CAND,S) 
            NORMAL MODE IS INTEGER 
            DIMENSION FIRST(5),SECOND(5) 
            ENTRY TO TESTS. 
            STORE=S 
            READER=SEQRDR.(CAND) 
            Through ONE, FOR I=0,1, I > 100 
            FIRST(I)=SEQLR.(READER,FR) 

;
; Copy all 6-character chunks of the candidate keyword to the FIRST array.
;
; [As the loop termination condition is I .G. 100 (000070), this code will
; write past the end of the FIRST array if the keyword is longer than 36
; characters (because the first 36 characters will be copied to
; FIRST(0) .. FIRST(5), and any further characters will be written to
; machine words past FIRST(5)).]
;

ONE         Whenever READER > 0, Transfer To ENDONE 
ENDONE      SEQLL.(S,F) 
            Through TWO, FOR J=0,1, J > 100 
            SECOND(J)=SEQLR.(S,F) 
TWO         Whenever S > 0, Transfer To ENDTWO 

;
; Copy all 6-character chunks of the user input word to the SECOND array.
; [May write past the end of SECOND.]
;

ENDTWO      Whenever I <> J, Function Return 0 
;
; If the keyword in FIRST has a different number of 6-character chunks to
; the word in SECOND the two words cannot be the same, so return the value 0,
; signifying no match.
;
; W'R is an abbreviation of WHENEVER
; .NE. means not equal
; F'N is an abbreviation of FUNCTION RETURN
;
            Through LOOK, FOR K=0,1, K> J 

LOOK        Whenever FIRST(K) <> SECOND(K), Function Return 0 
;
; Compare each 6-character chunk of the keyword with the corresponding chunk
; of the user input word. If any are different, return 0, signifying no match.
;
            EQL=SEQLR.(READER,FR) 
            Whenever EQL <> "=" 
            SEQLL.(READER,FR) 
            Function Return READER 
            Otherwise 
;
; At this point we know that the keyword matches the user's word.
; Check whether the transformation rules specify a simple word substitution,
; signified by the presence of an "=".
;
; If it is not an "=", reposition the reader back before the element and
; return the reader, signifying a successful match.
;
            POINT=LNKL.(STORE) 
            Through DELETE , FOR K=0,1, K > J 
            REMOVE.(LSPNTR.(STORE)) 
DELETE      SEQLR.(STORE,F) 
INSRT       NEW=SEQLR.(READER,FR) 
            POINT=NEWTOP.(NEW,POINT) 
            MRKNEG.(POINT) 
            Whenever READER < 0, Transfer To INSRT 
            MRKPOS.(POINT) 
            Function Return READER 
            End Conditional 
            End Function 
;
; An "=" was present in the transformation rule. E.g. a script
; transformation rule may begin
;
;           (YOUR = MY
;               ((0 MY 0)
;                   (WHY ARE YOU CONCERNED OVER MY 3)
;                   (WHAT ABOUT YOUR OWN 3)
;                   :
;
; Say at this point the keyword YOUR has been found in the user's input text
; and we know that in the transformation rule the keyword (YOUR) is followed
; by an "=". So we're now going to replace the YOUR in the input text with
; the word following the "=" in the transformation rule (MY, in this case).
; 
; First delete all the 6-character chunks that comprise this word, then
; insert all the 6-character chunks that comprise the replacement word. 
;
; Finally, return the reader, signifying a successful match.
;
        DOCBC 
            EXTERNAL FUNCTION (A,B) 
            NORMAL MODE IS INTEGER 
            ENTRY TO FRBCD. 
            Whenever LNKL.(A) = 0, Transfer To NUMBER 
            B=A 
            Function Return 0 
NUMBER      K=A*262144 
            B=BCDIT.(K) 
            Function Return 0 

            End Function 

;
; ELIZA entry point.
;
        ELIZA 
            NORMAL MODE IS INTEGER 
            DIMENSION KEY(32),MYTRAN(4) 
;
; KEY     - A hashmap used to record keywords.
;           KEY(0)..KEY(31)  is the keyword->transformation rule hashmap
;           KEY(32)          is the "NONE" transformation rule
;
; MYTRAN  - A hashmap used to record the MEMORY rules.
;           MYTRAN(1)..MYTRAN(4) contain the four MEMORY rules.
;
; A note on MAD arrays: DIMENSION D(N) allocates N+1 machine-words of
; core memory, which are accessed using indexes 0..N.
;
            INITAS.(0) 
;
; INITAS must be the first executable statement in any program using SLIP.
; Its purpose is to create the List of Available Space from all unused
; core memory. It does not require an argument, but here is given 0.
;
            PRINT COMMENT "WHICH SCRIPT DO YOU WISH TO PLAY" 
            READ FORMAT SNUMB,SCRIPT 
;
; Display the message "WHICH SCRIPT DO YOU WISH TO PLAY".
;
; Note that the IBM 7090/7094 character set doesn't include a question
; mark glyph. Also $ is used to delimit character strings.
;
; SNUMB is the FORTRAN format string " I3 *", defined previously, which
; expects the user to enter up to 3 decimal digits. This number is assigned
; to the variable SCRIPT and will be used as the tape drive unit number
; where the ELIZA script is expected to reside.
;
            LIST.(TEST) 
            LIST.(INPUT) 
            LIST.(OUTPUT) 
            LIST.(JUNK) 

;
; Initialise four lists. These are:
; TEST    - Used to store the parts of the user's text matching a
;           decomposition rule.
; INPUT   - During ELIZA startup the selected script is read into this list,
;           one round-bracketed list at a time.
;           During the conversation phase the text entered by the user is
;           read into this list.
; OUTPUT  - ELIZA's response sentence is constructed in this list.
; JUNK    - A list used for temporary storage for several different purposes.
;
            LIMIT=1 

;
; When Weizenbaum talks in the January 1966 CACM paper of a "certain counting
; mechanism", it is this to which he is referring. LIMIT has the value 1..4,
; in order, and then restarts at 1. The value changes to the next in the
; sequence at each user input. More on LIMIT below.
;
            LSSCPY.(THREAD.(INPUT,SCRIPT),JUNK) 
            MTLIST.(INPUT) 
;
; The THREAD function reads text from the tape unit specified by the integer
; SCRIPT into the INPUT list. The LSSCPY function copies the first list in
; that INPUT to the list named JUNK.
;
; The first list in an ELIZA script must be the hello message, e.g.
; (HOW DO YOU DO.  PLEASE TELL ME YOUR PROBLEM).)
;
            Through MLST, FOR I=1,1, I > 4 
MLST        LIST.(MYTRAN(I)) 
;
; Initialise each of the four MYTRAN array entries as a new list.
;
; T'H is an abbreviation for THROUGH
; .G. is the Boolean grater than operator
;
; Set I to 1, if I is greater than 4 stop looping, otherwise execute the code
; up to and including the statement labelled MLST. Then add 1 to I and return
; to the top of the loop at the point of the test to see if I is greater than
; 4 and repeat.
;
;   for I in 1..4 {
;     call function LIST with argument a reference
;       to the Ith entry in the MYTRAN array
;   }
;
            MINE=0 
            LIST.(MYLIST) 
;
; MINE    - Set to 0 and is never changed. It's referenced once below. ???
; MYLIST  - As memories are made using the MYTRAN MEMORY rules they are
;           recorded in MYLIST. Here MYLIST is being initialised as a new
;           empty list.
;
            Through KEYLST, FOR I=0,1, 1 > 32 
KEYLST      LIST.(KEY(I)) 
;
; Initialise each of KEY(0) .. KEY(32) array entries as a new list.
;   for I in 0..32 {
;     call function LIST with argument a reference
;       to the Ith entry in the KEY array
;   }
;

           R* * * * * * * * * * READ NEW SCRIPT 

BEGIN       MTLIST.(INPUT) 
            NODLST.(INPUT) 
            LISTRD.(INPUT,SCRIPT) 
;
; Empty the INPUT list. Remove the description list??? from INPUT (NODLST).
; Read the next round-bracket-delimited list from tape unit id SCRIPT.
;
            Whenever LISTMT.(INPUT) = 0 
                TXTPRT.(JUNK,0) 
                MTLIST.(JUNK) 
                Transfer To START 
            End Conditional 

;
; W'R is an abbreviation of WHENEVER.
; .E. means equals.
; T'O is an abbreviation for TRANSFER TO.
; E'L is an abbreviation of END OF CONDITIONAL.
;
; An empty list signals the end of the ELIZA script. (Which is presumably
; why there is () on the last line of the published DOCTOR script.)
;
;   if INPUT is the empty list {
;     (the whole ELIZA script has now been read and processed)
;     print the value of JUNK, e.g. "HOW DO YOU DO.  PLEASE TELL ME YOUR PROBLEM"
;     clear the JUNK list
;     goto the START label
;   } 
;
            Whenever TOP.(INPUT) = "NONE" 
                NEWTOP.(LSSCPY.(INPUT,LIST.(9)),KEY(32)) 
                Transfer To BEGIN 
;
; If this list is the special "NONE" list, just copy it unchanged into KEY(32)
; and then goto BEGIN to read the next list in the script.
;
; Recall that the NONE list in the DOCTOR script is:
;       (NONE
;           ((0)
;               (I AM NOT SURE I UNDERSTAND YOU FULLY)
;               (PLEASE GO ON)
;               (WHAT DOES THAT SUGGEST TO YOU)
;               (DO YOU FEEL STRONGLY ABOUT DISCUSSING SUCH THINGS)))
;
               OR Whenever TOP.(INPUT) = "MEMORY" 
                POPTOP.(INPUT) 
                MEMORY=POPTOP.(INPUT) 
                Through MEM, FOR I=1,1, I > 4 
MEM             LSSCPY.(POPTOP.(INPUT),MYTRAN(I)) 
                Transfer To BEGIN 
;
; Otherwise, if this list is the special "MEMORY" list, process it into the
; four MYTRAN lists. Recall that the MEMORY list looks like this and is
; required to have exactly four transformation patterns:
;       (MEMORY MY
;           (0 YOUR 0 = LETS DISCUSS FURTHER WHY YOUR 3)
;           (0 YOUR 0 = EARLIER YOU SAID YOUR 3)
;           (0 YOUR 0 = BUT YOUR 3)
;           (0 YOUR 0 = DOES THAT HAVE ANYTHING TO DO WITH THE FACT THAT YOUR 3))
;
;   else if the first word in INPUT is "MEMORY" {
;     assign the memory keyword (e.g. "MY") to the MEMORY variable
;     for I in 1..4 {
;       copy the Ith MEMORY pattern/reconstruction to MYTRAN(I)
;     }
;     goto the BEGIN label (continue reading the ELIZA script)
;   }
;
               Otherwise 
                NEWBOT.(LSSCPY.(INPUT,LIST.(9)),KEY(HASH.(TOP.(INPUT),5))) 
                Transfer To BEGIN 
            End Conditional 
;
; Otherwise, the first word in the INPUT list is expected to be a keyword.
; Insert this keyword into the KEY hashtable, so that
;   KEY(HASH(keyword)) -> list of transformation rules for keywords
;                         that hash to this entry in KEY (i.e. more than
;                         one keyword may hash to the same entry in KEY,
;                         so each entry in KEY may have zero, one or many
;                         keyword transformation rules associated with it.)
;
; (1 in column 11 signifies a continuation of the previous line.)
;
; The HASH function takes a word and a number (N) and returns a deterministic
; value between 0 and (2 to the power N)-1, in this case 0..31.
;
;   else {
;     HASH the keyword and append this transformation rule to the
;       entry in KEY with that index
;     goto the BEGIN label (continue reading the ELIZA script)
;   }
;
; This is the end of the script reading code. When the script has been
; read and processed the script reader explicitly jumps to the START label
; to begin the user conversation.
;
           R* * * * * * * * * * BEGIN MAJOR LOOP 

START       TREAD.(MTLIST.(INPUT),0) 
;
; Wait for the user to type a sentence and read it into the INPUT list,
; which is first cleared. Presumably, tape unit 0 is the console.
;
; TREAD is the SLIP system text read function.
;
            KEYWRD=0 
            PREDNC=0 
;
; KEYWRD  - This will be the keyword found to have the highest precedence.
; PREDNC  - The precedence of the keyword. Precedence is specified in the
;           ELIZA script. E.g. (DREAMS = DREAM 3 (=DREAM)), the keyword
;           DREAMS is given the precedence value 3.
;
            LIMIT=LIMIT+1 
            Whenever LIMIT = 5, LIMIT=1 
;
; Increment the value of LIMIT. If it then equals 5, set it back to 1.
; If we just read the very first user input, LIMIT will now have the value 2.
;
            Whenever LISTMT.(INPUT) = 0, Transfer To ENDPLA 
;
; If the user input is a blank line, goto the ENDPLA label.
; A blank user input tells ELIZA the conversation is over.
;
            IT=0 
;
; IT      - On exit from the scanning loop IT will either be the sequence
;           reader for the selected transformation rule, or it will be 0
;           indicating that no keyword was detected in the user's INPUT.
;
            Whenever TOP.(INPUT) = "+" 
                CHANGE.(KEY,MYTRAN) 
                Transfer To START 
            End Conditional 
;
; If first word of the user input is a "+" character, call the CHANGE
; function defined higher up in this code. This function allows the user
; to modify the current ELIZA script with the commands TYPE, SUBST,
; APPEND, ADD, START, RANK and DISPLA.
; After making any changes, return to the START label and carry on the
; conversation.
;
            Whenever TOP.(INPUT) = "*", Transfer To NEWLST 
;
; If first word of the user input is a "*" character, goto the NEWLST label.
; NEWLST is defined later in this code. It inserts a new transformation rule,
; which the user will have given after the "*", into the current in-memory
; script and then returns to the START label to carry on the conversation.
;
            S=SEQRDR.(INPUT) 
;
; Create the Slip sequence reader, S, for the user's INPUT list.
;
NOTYET      Whenever S < 0 
                SEQLR.(S,F) 
                Transfer To NOTYET 
;
; ???
;
               Otherwise 
                WORD=SEQLR.(S,F) 
                Whenever WORD = "." OR WORD = "," OR WORD = "BUT" 
                    Whenever IT = 0 
                        NULSTL.(INPUT,LSPNTR.(S),JUNK) 
                        MTLIST.(JUNK) 
                        Transfer To NOTYET 
                       Otherwise 
                        NULSTR.(INPUT,LSPNTR.(S),JUNK) 
                        MTLIST.(JUNK) 
                        Transfer To ENDTXT 
                       End Conditional 
                    End Conditional 
                End Conditional 
;
; Set the variable WORD to the next word in the user's INPUT list. Then
; test that word to see if it's a delimiter.
;
; Note that in Weizenbaum's 1966 CACM paper, only comma and period were
; listed as delimiters. And yet the example conversation given in that
; paper could not be reproduced unless BUT is also a delimiter.
;
; Note that WORD is a 36-bit integer. Weizenbaum developed ELIZA between
; 1964 and 1966 on an IBM 7094, which has a 36-bit word and uses a 6-bit
; character encoding. Characters were packed 6 to a word. In Slip, character
; strings longer than six characters are stored in successive list cells.
; In this case WORD=SEQLR.(S,F) is assigning the first six characters of
; the next word in the user's INPUT text to the integer variable WORD.
; If the word had fewer than six characters they would be left justified
; with space characters padding to the right.
; 
;
;   else {
;     if WORD is one of the delimiters ".", "," or "BUT" {
;       if we have found no keywords in the INPUT so far (IT .E. 0) {
;         discard all words in INPUT to the left of, and including, this
;           delimiter
;         goto NOTYET and continue scanning the rest of the user INPUT
;           for keywords
;       }
;       else {
;         discard all words in INPUT to the right of, and including, this
;           delimiter
;         goto ENDTXT; scanning of the user INPUT is now complete
;       }
;     }
;   }
;
                Whenever F > 0, Transfer To ENDTXT 
;
; If there were no more words to read in the user INPUT list, goto the
; ENDTXT label; scanning of the user INPUT is now complete.
; (F will be 1 when the sequence reader has traversed the whole INPUT
; list and is back at the list header.)
;
                I=HASH.(WORD,5) 
                SCANER=SEQRDR.(KEY(I)) 
                SF=0 
                Through SEARCH, FOR J=0,0, SF > 0 
                CAND= SEQLR.(SCANRE,SF) 
                Whenever SF > 0, Transfer To NOTYET 
SEARCH          Whenever TOP.(CAND) = WORD, Transfer To KEYFND 
;
; Is WORD a keyword? Try to locate it in the KEY hashmap.
;
; Recall that more than one keyword may hash to the same entry in KEY,
; so each entry in KEY is a list that may have zero, one or many keyword
; transformation rules associated with it. We need to look through this
; list to see if it contains a keyword that exactly matches WORD.
;
;   HASH the WORD to get the index I in the KEY table where this word
;     would have been stored, if it is a keyword
;   loop {
;     try to read the next candidate list from the hashmap entry KEY(I)
;     if there isn't another candidate list {
;       WORD didn't match any entries so it's not a keyword
;       goto NOTYET to continue scanning the user's input text
;     }
;     if WORD is the same as the first entry in this candidate list {
;       WORD is a keyword and CAND is the transformation rule for
;       this keyword, so goto KEYFND
;     }
;   }
;
KEYFND          READER=TESTS.(CAND,S) 
                Whenever READER = 0, Transfer To NOTYET 
;
; Call the TESTS function, defined higher up in this code.
; 
; TESTS checks that the whole keyword matches the whole user INPUT word. It
; also performs any keyword substitution in the user INPUT. (e.g. (MY = YOUR))
;
; If TESTS returns 0 it means the keyword is not identical to the word in
; the user input, so goto NOTYET to continue scanning the user INPUT.
;
; [This suggests that keywords must differ in the first six characters.
; (Because TESTS is called only for the first keyword candidate in
; the KEY hashmap that matches the first six characters of the user's
; input word).]
;
                Whenever LSTNAM.(CAND) <> 0 
                    DL=LSTNAM.(CAND) 
SEQ                 Whenever S < 0 
                        SEQLR.(S,F) 
                        Transfer To SEQ 
                       Otherwise 
                        NEWTOP.(DL,LSPNTR.(S)) 
                    End Conditional 
                   Otherwise 
                End Conditional 
                NEXT=SEQLR.(READER,FR) 
                Whenever FR > 0, Transfer To NOTYET 
;
; Read the next element in the rules associated with this keyword.
; If we are back at the rules header, the rules list was empty, so goto
; NOTYET to continue scanning the user INPUT.
;
                Whenever IT = 0 AND FR = 0 
PLCKEY              IT=READER 
                    KEYWRD=WORD 
;
; 001000 If this is the first keyword we've encountered in the user's INPUT
; (IT .E. 0), and the first entry in the associated rules is a list
; rather than a value (FR .E. 0)???, i.e. there is no precedence associated
; with this keyword, then record the associated rules reader in IT and
; the found keyword in KEYWRD. Then goto NOTYET (001100) to continue
; scanning the user's input.
;
                   OR Whenever FR < 0 AND NEXT > PREDNC 
                    PREDNC=NEXT 
                    NEXT=SEQLR.(READER,FR) 
                    Transfer To PLCKEY 
                   Otherwise 
                    Transfer To NOTYET 
                End Conditional 
                Transfer To NOTYET 

               R* * * * * * * * * * END OF MAJOR LOOP 
;
; 001030 Otherwise, if the first entry in the associated rules is a value???
; (FR .L. 0), i.e. the precedence of this keyword, and that value is greater
; than the precedence of the previously found highest precedence keyword
; (NEXT .G. PREDNC), then record the new highest precedence value in PREDNC
; and move the rule reader past the precedence value, then goto PLCKEY to
; also record the reader in IT and the found keyword in KEYWRD. Finally, goto
; NOTYET (001100) to continue scanning the user's input.
;
; Note that this differs from Weizenbaum's CACM paper, where it says that
; keywords of higher precedence are added to the top of a keyword stack and
; keywords of lower precedence are added to the bottom of this stack. This
; also means this code does not support the "NEWKEY" functionality he
; describes.
;
; [Note that this code implies that keywords in the script should never
; specify a precedence value of 0. If they do they would never be used
; (because NEXT .G. PREDNC will never be true).]
;
; 001080 Otherwise, ignore this keyword and return to NOTYET to continue
; scanning the user's INPUT.
;
ENDTXT          Whenever IT = 0 
                    Whenever LIMIT = 4 AND LISTMT.(MYLIST) <> 0 
                        OUT=POPTOP.(MYLIST) 
                        TXTPRT.(OUT,0) 
                        IRALST.(OUT) 
                        Transfer To START 
                       Otherwise 
                        ES=BOT.(TOP.(KEY(32))) 
                        Transfer To TRY 
                    End Conditional 
;
; 001120 If IT is 0 it means we did not find any keywords in the user's
; input, so we cannot construct a response from the user's input combined
; with any of the transformation rules in the script.
;
; Instead we do one of two things: either print one of the memories we
; previously recorded in MYLIST, if any, or we use one of the messages
; from the NONE list (which is recorded in KEY(32)).
;
; 001130 This is the mysterious "when a certain counting mechanism is in a
; particular state": recall a memory only if the memory list (MYLIST) isn't
; empty and LIMIT happens to have the value 4.
;
                   OR Whenever KEYWRD = MEMORY 
                    I=HASH.(BOT.(INPUT),2)+1 
                    NEWBOT.(REGEL.(MYTRAN(I),INPUT,LIST.(MINE)),MYLIST) 
                    SEQLL.(IT,FR) 
                    Transfer To MATCH 
;
; Otherwise, we did find a keyword (IT .E. 0 is false). If the keyword is
; the MEMORY keyword ("MY" in the DOCTOR script), then add a new memory to
; MYLIST before we carry on processing the transformation rules associated
; with the matched keyword.
;
; In the 1966 CACM paper, Weizenbaum says the selection of one of the
; transformations on the MEMORY list is random. The code shows that the
; selection is determined by the HASH value of the last word in the user's
; input. This means ELIZA conversations are repeatable, not random. If we
; have the HASH algorithm we should be able to reproduce the exact
; conversation. (The HASH function is part of the SLIP system.)
;
                   Otherwise 
                    SEQLL.(IT,FR) 
;
; Otherwise, the keyword we found isn't the MEMORY keyword, so just position
; the transformation rule sequence reader past the keyword and fall through
; to the matching code.
;
               R* * * * * * * * * * MATCHING ROUTINE 

MATCH               ES=SEQLR.(IT,FR) 
                    Whenever TOP.(ES) = "=" 
                        S=SEQRDR.(ES) 
                        SEQLR.(S,F) 
                        WORD=SEQLR.(S,F) 
                        I=HASH.(WORD,5) 
                        SCANER=SEQRDR.(KEY(I)) 
SCAN                    ITS=SEQLR.(SCANER,F) 
                        Whenever F > 0, Transfer To NOMATCH(LIMIT) 
                        Whenever WORD = TOP.(ITS) 
                            S=SEQRDR.(ITS) 
SCANI                       ES=SEQLR.(S,F) 
                            Whenever F <> 0, Transfer To SCANI 
                            IT=S 
                            Transfer To TRY 
                        Otherwise 
                            Transfer To SCAN 
                        End Conditional 
                    End Conditional 
                    Whenever FR > 0, Transfer To NOMATCH(LIMIT) 

;;; A lot of the core work is done by the complex SLIP matching and
;;; rebuilding functions YMATCH and ASSMBL (see the latter at HIT)
;;; These are described on pages 62L28-29 of the SLIP manual:
;;;    https://drive.google.com/file/d/1XtF7EM1KhwMPKsp5t6F0gwN-8LsNDPOl
;
; If this keyword is a link to another keyword, switch to that keyword.
;
; An ELIZA script rule may have the form (HOW (=WHAT)). If the keyword
; HOW appears in the user's input and this transformation rule is selected,
; ELIZA will use the transformation rule associated with the keyword WHAT
; to generate its response.
;
;   read the next decomposition rule from the selected transformation rule
;   if the decomposition rule starts with an "=" symbol {
;     assign the word after the "=" to WORD
;     lookup WORD in the KEY hashmap
;     if WORD doesn't exist in the KEY hashmap {
;       (presumably this indicates a logical inconsistency in the script)
;       goto one of the NOMATCH(1) .. NOMATCH(4) labels to print
;         a message such as "HMMM" and back to the main conversation loop
;       which NOMATCH label is selected is determined by the value LIMIT
;         happens to have at this time
;     }
;     else {
;       position IT at first decomposition rule for the linked keyword
;       goto the TRY label to try to apply the decomposition rule
;     }
;   }
;   else if there were no (or no more) decomposition rules (FR .G. 0) {
;     (does this indicate an incorrectly formed script?)
;     goto one of the NOMATCH(1) .. NOMATCH(4) labels
;   }
;
TRY                 Whenever YMATCH.(TOP.(ES),INPUT,MTLIST.(TEST)) = 0,Transfer To MATCH 
;
; Attempt to match the current decomposition rule (TOP.(ES)) to the user's
; INPUT.
;
; If it doesn't match (YMATCH returns 0), goto MATCH to try the next
; decomposition rule in the current transformation rule set.
;
; If it does match, the list TEST will contain the decomposed matching parts
; of the INPUT text ready for reassembly. E.g. ???
;
; The YMATCH function is part of the SLIP system.
;
                    ESRDR=SEQRDR.(ES) 
                    SEQLR.(ESRDR,ESF) 
                    POINT=SEQLR.(ESRDR,ESF) 
                    POINTR=LSPNTR.(ESRDR) 
                    Whenever ESF = 0 
                        NEWBOT.(1,POINTR) 
                        TRANS=POINT 
                        Transfer To HIT 
                       Otherwise 
                        Through FNDHIT,FOR I=0,1, I > POINT 
FNDHIT                  TRANS=SEQLR.(ESRDR,ESF) 
                        Whenever ESF > 0 
                            SEQLR.(ESRDR,ESF) 
                            SEQLR.(ESRDR,ESF)                                   
                            TRANS=SEQLR.(ESRDR,ESF) 
                            SUBST.(1,POINTR) 
                            Transfer To HIT 
                           Otherwise 
                            SUBST.(POINT+1,POINTR) 
                            Transfer To HIT 
                        End Conditional 
                    End Conditional 
;
; Select one of the reassembly rules associated with this decomposition rule.
;
; Reassembly rules are used in turn. This code adds a counter (001560) to
; the rules and uses it to record which reassembly rule was used last (001690).
; When all reassembly rules have been used (001620) the counter is returned
; to 1 (001660) and the first rule is used again.
;
HIT                 TXTPRT.(ASSMBL.(TRANS,TEST,MTLIST.(OUTPUT)),0)  ;; See above, re SLIP functions YMATCH and ASSMBL
                    Transfer To START 
                End Conditional 

               R* * * * * * * * * * INSERT NEW KEYWORD LIST 
;
; Finally, use the selected reassembly rule (TRANS) and list of decomposition
; parts (TEST) to assemble a response (in the list OUTPUT) and print it. Then
; goto the START label to await the next user input and continue the
; conversation.
;
; The ASSMBL function is part of the SLIP system.
;
; The E'L (END OF CONDITIONAL) on line 001750 closes the O'E (OTHERWISE)
; on line 001270. ???
;
NEWLST          POPTOP.(INPUT) 
                NEWBOT.(LSSCPY.(INPUT,LIST.(9)),KEY(HASH.(TOP.(INPUT),5))) 
                Transfer To START 

               R* * * * * * * * * * DUMP REVISED SCRIPT 

ENDPLA          PRINT COMMENT "WHAT IS TO BE THE NUMBER OF THE NEW SCRIPT" 
                READ FORMAT SNUMB,SCRIPT 
                LPRINT.(INPUT,SCRIPT) 
                NEWTOP.(MEMORY,MTLIST.(OUTPUT)) 
                NEWTOP.("MEMORY",OUTPUT) 
                Through DUMP, FOR I=1,1 I > 4 
DUMP            NEWBOT.(MYTRAN(I),OUTPUT) 
                LPRINT.(OUTPUT,SCRIPT) 
                MTLIST.(OUTPUT) 
                Through WRITE, FOR I=0,1, I > 32 
POPMOR          Whenever LISTMT.(KEY(I)) = 0, Transfer To WRITE 
                LPRINT.(POPTOP.(KEY(I)),SCRIPT) 
                Transfer To POPMOR 
WRITE           CONTINUE 
                LPRINT.(MTLIST.(INPUT),SCRIPT) 
                EXIT. 

               R* * * * * * * * * * SCRIPT ERROR EXIT 

NOMATCH(1)      PRINT COMMENT "PLEASE CONTINUE " 
                Transfer To START 
NOMATCH(2)      PRINT COMMENT "HMMM " 
                Transfer To START 
NOMATCH(3)      PRINT COMMENT "GO ON , PLEASE " 
                Transfer To START 
NOMATCH(4)      PRINT COMMENT "I SEE " 
                Transfer To START 
                VECTOR VALUES SNUMB= "I3 * " 
                End of Program 

